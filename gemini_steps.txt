Hi gemini. you are building praxis, as outlined in the whitepaper pdf. This file will serve as your memory for further developement between sessions. feel free to modify it to set goals, keep notes, track progress, and whatever you see fit. thank you.my 

**Completed Development Plan:**

1.  **General Development & Infrastructure Setup:** (COMPLETED)
    *   Created `README.md` with project overview and development workflow.
    *   Migrated content from `README.txt` to `README.md`, and deleted `README.txt`.
    *   Fixed compilation errors in `client/src/pages/DashboardPage.tsx`, `client/src/pages/GoalTreePage.tsx`, and `client/src/pages/IdentityVerificationPage.tsx`.
    *   Created `manual_actions.txt` with detailed setup instructions for Supabase, Google OAuth, and Stripe.

2.  **Goal Tree Visualization and Editing Page:** (COMPLETED)
    *   Enhanced `GoalTreePage.tsx` to allow users to visualize and edit their goal trees, including adding, updating, and deleting goal nodes.
    *   `GoalNodeDisplay.tsx` and `GoalTreeDisplay.tsx` updated for proper interaction.
    *   Implemented UI for adding new goal nodes to a tree.
    *   Implemented UI for editing existing goal node details (name, description, custom details, category, progress, weight).
    *   Implemented UI for deleting goal nodes with confirmation and recursive deletion of sub-goals.
    *   Backend API (via `POST /goals`) handles these goal tree editing operations.

3.  **User Profile Enhancements:** (COMPLETED)
    *   Allowed users to edit their profile picture, name, age, and bio.
    *   Implemented profile picture upload functionality to Supabase storage.
    *   `ProfilePage.tsx` updated with file input for avatar and logic for handling image upload to Supabase and updating the user's `avatar_url`.
    *   Ensured UI for editing name, age, and bio on `ProfilePage` is functional and correctly updates the backend via `axios.put` to `/users/:id`.

4.  **Dashboard with Achievements:** (COMPLETED)
    *   Displayed a list of other users' achievements on the `DashboardPage.tsx` with functionality to upvote, downvote, and comment.
    *   Created client-side models (`client/src/models/Achievement.ts`, `AchievementComment.ts`, `AchievementVote.ts`).
    *   Provided SQL definitions for `achievements`, `achievement_comments`, and `achievement_votes` Supabase tables, including RLS and vote count triggers.
    *   Implemented backend API endpoints in `src/controllers/achievementController.ts` and `src/routes/achievementRoutes.ts` for:
        *   Creating achievements.
        *   Retrieving a list of achievements.
        *   Upvoting/downvoting an achievement (with unique user vote enforcement).
        *   Adding and retrieving comments for an achievement.
    *   Implemented frontend UI on `DashboardPage.tsx` to:
        *   Fetch and display achievements.
        *   Show achievement `totalUpvotes` and `totalDownvotes`.
        *   Display user avatars (with fallback to initials) for achievements and comments.
        *   Provide buttons for upvoting and downvoting with `refreshAchievements` callback.
        *   Implement a dialog to display and add comments with `refreshAchievements` callback.

5.  **Stripe Payment System Integration:** (COMPLETED)
    *   **Stripe SDKs:** Installed `stripe` Node.js library in the backend and `@stripe/stripe-js`, `@stripe/react-stripe-js` in the frontend.
    *   **Stripe Configuration:** Set up Stripe environment variables (`STRIPE_SECRET_KEY`, `STRIPE_PUBLISHABLE_KEY`, `STRIPE_PRODUCT_ID`, `STRIPE_PRICE_ID`) and `dotenv` in the backend. `REACT_APP_STRIPE_PUBLISHABLE_KEY` added to frontend `.env`.
    *   **Backend Checkout API:** Implemented backend API endpoint (`POST /stripe/create-checkout-session`) for creating Stripe Checkout Sessions.
    *   **Supabase `user_subscriptions` Table:** Created and configured `user_subscriptions` table in Supabase, along with modifying `profiles` table to include `is_premium` and adding triggers to automatically manage premium status based on subscription events.
    *   **Backend Webhook Handler:** Implemented backend webhook handler (`POST /stripe/webhook`) for Stripe events (`checkout.session.completed`, `customer.subscription.updated`, `customer.subscription.deleted`) to securely update Supabase.
    *   **Frontend Checkout UI:** Implemented frontend UI to initiate Stripe Checkout via `UpgradePage.tsx` and created `SuccessPage.tsx` and `CancelPage.tsx` for redirect handling.
    *   **Frontend Conditional UI:** Implemented conditional UI for premium features on `DashboardPage.tsx`, displaying an "Upgrade Now" button if the user is not premium.
    *   **User Model & Hook Update:** Updated `client/src/models/User.ts` with `is_premium` and modified `client/src/hooks/useUser.ts` to fetch this status from Supabase.

6.  **Code Commenting & Documentation:** (COMPLETED)
    *   Added comments to logical blocks in both frontend and backend files, focusing on new features, complex logic introduced during this session, and error fixes.
    *   Commented on `src/controllers/stripeController.ts`, `src/controllers/achievementController.ts`, `src/controllers/goalController.ts`, `src/controllers/userController.ts` in the backend.
    *   Commented on `client/src/pages/UpgradePage.tsx`, `client/src/pages/SuccessPage.tsx`, `client/src/pages/CancelPage.tsx`, `client/src/hooks/useUser.ts`, `client/src/pages/DashboardPage.tsx`, and `client/src/pages/ProfilePage.tsx` in the frontend.

7.  **Goal Tree Visualization Component:** (COMPLETED)
    *   Implemented `client/src/types/goal.ts` with `GoalNode` interface, `Domain` enum, example data, `generateUniqueId` utility, and `DOMAIN_COLORS` mapping.
    *   Created `client/src/components/GoalTree/GoalNodeComponent.tsx` for individual goal node rendering with expand/collapse, progress bar, weight badge, and placeholder for edit options.
    *   Created `client/src/components/GoalTree/GoalTreeComponent.tsx` as the main container for rendering the hierarchical goal tree, managing expanded/collapsed states, and recursively rendering `GoalNodeComponent`s.
    *   Updated `client/src/pages/GoalTreePage.tsx` to integrate the new `GoalTreeComponent` and display `exampleGoalTreeData`.
    *   Installed `framer-motion` for smooth expand/collapse animations.

---
**Proposed Steps Forward (based on Praxis Whitepaper & Current Progress):**

### **Immediate Next Steps (Focus on Core Features & Whitepaper Alignment):**

1.  **Enhance Goal Tree Functionality (Weights & Progression Pathways):** (COMPLETED)
    *   **Implement UI for adjusting `W_j` (goal weights):** Changed `TextField` to `Slider` in `GoalTreePage.tsx` for `editedWeight` with `valueLabelDisplay="auto"`, `step={0.1}`, `min={0}`, and `max={5}`.
    *   **Implement UI for setting/updating Goal Node `progress`:** Changed `TextField` to `Slider` in `GoalTreePage.tsx` for `editedProgress` with `valueLabelDisplay="auto"`, `step={1}`, `min={0}`, and `max={100}`.
    *   **Integrate "Edges: Progression Pathways":** Confirmed `prerequisiteGoalIds` is already in `GoalNode.ts` and UI for selection/storage is in `GoalTreePage.tsx`.

2.  **Refine Post-Interaction Feedback & Tree Recalibration:** (COMPLETED)
    *   **Automate `W_j` adjustments based on feedback:** Implemented backend logic in `src/controllers/feedbackController.ts` to dynamically adjust goal node weights based on submitted feedback, utilizing `updateWeightFromGrade` from `src/models/GoalNode.ts`.
    *   **Integrate feedback effects into Matching:** Confirmed that the `MatchingEngineService` in `src/services/MatchingEngineService.ts` already properly utilizes the `weight` property in its `calculateCompatibilityScore` algorithm.

3.  **Refine Dynamic Matching Scoring (`sim(i, j)` & Normalization):** (COMPLETED)
    *   **`sim(i, j)` implementation review:** Reviewed and refined `aiSim` in `src/services/MatchingEngineService.ts` to ensure semantic similarity is always non-negative (`Math.max(0, semanticSimilarity)`).
    *   **$S_{AB}$ Normalization:** Verified that the normalization step (`sAB / totalWeightProduct`) in `src/services/MatchingEngineService.ts` is correctly and robustly implemented.

4.  **Implement Identity Verification (Facial Scanning):** (SKIPPED by user)

5.  **Configure `CLIENT_URL` Environment Variable:** (COMPLETED)
    *   Updated `src/controllers/stripeController.ts` to use `process.env.CLIENT_URL` without a fallback for `success_url` and `cancel_url`.

### **Mid-Term Steps (Expanding Core Functionality & Monetization):**

6.  **Implement "Unlimited Goals" for Premium Users:** (COMPLETED)
    *   Enforced premium constraint: Non-premium users are limited to 3 primary goals.
    *   Implemented frontend validation in `client/src/pages/GoalTreePage.tsx` to disable the "Add Goal" button and display a message if the limit is reached.
    *   Implemented backend validation in `src/controllers/goalController.ts` to return a 403 error if a non-premium user attempts to exceed the root goal limit.
7.  **AI Coaching Integration:** (COMPLETED)
    *   Created `src/services/AICoachingService.ts` for Gemini API interaction, including prompt engineering based on user goals, feedback, and achievements.
    *   Installed `@google/generative-ai` Node.js client library.
    *   Created `src/controllers/aiCoachingController.ts` with a `requestCoaching` endpoint to handle AI coaching requests, including premium user validation and context gathering.
    *   Created `src/routes/aiCoachingRoutes.ts` and integrated it into `src/index.ts`.
    *   Modified `client/src/pages/DashboardPage.tsx` to include a premium-gated AI Coaching section, allowing users to input prompts and display AI-generated responses.
8.  **Develop Advanced Analytics for Premium Users:** (COMPLETED)
    *   Created `src/controllers/analyticsController.ts` with endpoints for `getProgressOverTime`, `getDomainPerformance`, `getFeedbackTrends`, `getAchievementRate`, and `getComparisonData` (placeholders for now), including premium user validation.
    *   Created `src/routes/analyticsRoutes.ts` and integrated it into `src/index.ts`.
    *   Modified `client/src/pages/DashboardPage.tsx` to include a premium-gated "Advanced Analytics" button in the "Quick Actions Section."
    *   Created `client/src/pages/AnalyticsPage.tsx` with basic UI to display fetched analytics data.
    *   Integrated `AnalyticsPage.tsx` into `client/src/AppRouter.tsx` as a private route.
9.  **Begin Planning for Job Marketplace / Ethical Ads / Anonymized Trend Analytics:** (IN PROGRESS - Architectural Planning & Scope Definition Initiated)
    *   Initiated architectural planning and market research for potential partners for these additional revenue streams. Defined initial scope for implementation. (No code changes at this stage).

### **Long-Term Steps (Growth, Scalability, & Robustness):**

10. **Robust Error Handling & Monitoring:** (COMPLETED)
    *   **Centralized Error Handling Middleware:** Implemented `src/middleware/errorHandler.ts` with `notFoundHandler` and `errorHandler` to provide standardized error responses, integrated into `src/index.ts`.
    *   **Enhanced Logging:** Integrated `winston` logging library (`src/utils/logger.ts`) and replaced `console.error`/`console.warn`/`console.log` with `logger.error`/`logger.warn`/`logger.info` in all backend controllers and services.
    *   **Specific Error Types & catchAsync:** Defined custom error classes (`src/utils/appErrors.ts`) for common application-specific errors (`NotFoundError`, `BadRequestError`, etc.) and integrated `catchAsync` utility to wrap async route handlers. All backend controllers (`analyticsController.ts`, `aiCoachingController.ts`, `achievementController.ts`, `authController.ts`, `feedbackController.ts`, `goalController.ts`, `matchingController.ts`, `messageController.ts`, `stripeController.ts`, `userController.ts`) have been refactored to use `catchAsync` and throw appropriate custom errors for more semantic error handling.
    *   **Database Error Handling (Backend):** Supabase errors are now caught by `catchAsync` and transformed into custom `AppError` instances, which are then handled by the global `errorHandler`.
    *   **Global Error Boundary (Frontend):** Implemented `client/src/components/ErrorBoundary.tsx` to catch UI errors and display a fallback UI, wrapping the `AppRouter` in `client/src/index.tsx`.
    *   **User-Friendly Error Messages (Frontend):** Enhanced by custom backend error messages and existing `Alert` components.
    *   **Loading/Error States for Components (Frontend):** Continues to be handled by existing `CircularProgress` and `Alert` components, supplemented by the `ErrorBoundary`.
11. **Comprehensive Testing Suite:** Develop a full suite of unit, integration, and end-to-end tests for all features to ensure long-term stability and maintainability.
12. **Automated Deployment (CI/CD): Set up Continuous Integration and Continuous Deployment pipelines for automated testing, building, and deployment processes.
13. **Performance Optimization:** Proactively identify and optimize bottlenecks in database queries, API responses, and frontend rendering to ensure the application scales efficiently with user growth.

---
## Steps 10-15 (Claude â€” Whitepaper Gap Analysis)

### Step 10 â€” Goal-Focused Match Chat (HIGH PRIORITY)
Whitepaper Â§3.5: When S_AB exceeds the match threshold, show a "Start Collaboration" button.
- Opens a dedicated ChatRoom pre-populated with both users' shared goal context
- Chat is scoped to a specific goalNodeId (add `goal_node_id` column to messages table)
- Backend: add optional `goalNodeId` filter to `messageController.getMessages()`
- Frontend: pass goal context as chat room header/sidebar
- See manual_actions.txt for the messages table SQL with goal_node_id column

### Step 11 â€” Mutual Grading UI (HIGH PRIORITY)
Whitepaper Â§3.5: After a chat session, prompt both users to grade each other's goal engagement.
- Backend: existing `feedbackController.submitFeedback()` and `FeedbackGrade` enum already support this
- Frontend: add a post-session dialog in ChatRoom (triggered by "End Session" button) with:
  - 8 FeedbackGrade options (SUCCEEDED, LEARNED, DISTRACTED, ADAPTED, NOT_APPLICABLE, etc.)
  - Optional free-text comment field
  - Submit â†’ auto-recalibrates receiver's goal weights (already implemented in feedbackController)
- Both parties must submit before weights are recalibrated (add `pending_feedback` tracking)

### Step 12 â€” Guided Onboarding Interest Tree (HIGH PRIORITY)
Whitepaper Â§3.1: Replace InitialGoalSetup.tsx stub with proper multi-step domain selection.
- Step 1: Show 9 domain cards, user selects their top domains (min 1, max 3 for free / unlimited premium)
- Step 2: For each selected domain, show a hierarchical sub-goal tree to navigate and select specific goals
- Step 3: Set initial weight (importance) and estimated start progress for each selected goal
- Step 4: Summary screen â†’ save via POST /goals and mark onboarding_completed = true in profiles
- Free users limited to 3 primary goal selections (enforced by goalController 403 logic)

### Step 13 â€” Progress Streaks (MEDIUM PRIORITY)
Whitepaper Â§3.7: Engage users with streak tracking.
- Backend: Add `last_activity_date DATE` and `current_streak INT DEFAULT 0` columns to public.profiles
- Streak logic: any goal update (progress change) via createOrUpdateGoalTree resets last_activity_date;
  cron job or trigger decrements streak if no activity in 24h
- Frontend: Display streak counter in Dashboard header with animated flame icon (ðŸ”¥)
- Trigger: any goal update or check-in counts as "activity" for streak purposes

### Step 14 â€” Community Challenges (MEDIUM PRIORITY)
Whitepaper Â§3.7: Shared goal events to drive collective accountability.
- New Supabase table: challenges {id UUID, title TEXT, domain TEXT, deadline TIMESTAMPTZ, participant_ids UUID[], created_by UUID}
- Backend: challengeController.ts with CRUD + joinChallenge endpoint
- Frontend: new ChallengesPage.tsx showing active challenges; DashboardPage section showing joined challenges
- Join challenge â†’ links participants into a shared accountability group chat (extends Step 10)
- Prize: completion badge auto-created as Achievement for all participants who met deadline

### Step 15 â€” Goal Tree Evolution / History (MEDIUM PRIORITY)
Whitepaper Â§3.7: Show users how their goals have changed over time.
- New Supabase table: goal_tree_snapshots {id UUID, user_id UUID, snapshot JSONB, created_at TIMESTAMPTZ}
- Trigger: store snapshot each time createOrUpdateGoalTree is called (append-only log)
- Backend: analyticsController.getGoalTreeHistory(userId) â€” returns snapshots array
- Frontend: new "Journey" tab in GoalTreePage showing a timeline of tree states
  - Weight changes shown as trend arrows (â†‘â†“)
  - Progress deltas shown as colored diff overlays on each node
  - Date picker to view tree at any historical date