================================================================================
  PRAXIS — MANUAL ACTIONS REQUIRED
  Complete these steps in order. Each section is labeled with where to act.
================================================================================

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
STEP 1 — ROTATE EXPOSED KEYS  ⚠️  DO THIS BEFORE ANYTHING ELSE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Your Supabase anon key, Supabase service role key, and Stripe secret key were
committed to git history. Even after `git rm`, they are recoverable from old
commits. Rotate them now.

─── 1A. Rotate Stripe Secret Key ───────────────────────────────────────────────
  WHERE: https://dashboard.stripe.com/test/apikeys

  1. Find "Secret key" (starts with sk_test_...).
  2. Click the "..." menu → "Roll key" → confirm in the dialog.
     The old key is immediately invalidated.
  3. Copy the new secret key.
  4. Open:  praxis_webapp/.env
     Update: STRIPE_SECRET_KEY=sk_test_<new_value>

─── 1B. Rotate Supabase Anon Key ───────────────────────────────────────────────
  WHERE: https://supabase.com/dashboard/project/<your-project-id>/settings/api
         (your project ID is in the URL when you open your project)

  1. Under "Project API keys", find the "anon / public" row.
  2. Click "Generate new key" → confirm.
  3. Copy the new anon key.
  4. Open:  praxis_webapp/client/.env
     Update: REACT_APP_SUPABASE_ANON_KEY=<new_value>

─── 1C. Rotate Supabase Service Role Key ───────────────────────────────────────
  WHERE: Same page as 1B.

  1. Find the "service_role" row → "Generate new key" → confirm.
  2. Copy the new service role key.
  3. Open:  praxis_webapp/.env
     Update: SUPABASE_SERVICE_ROLE_KEY=<new_value>

  ⚠️  The service role key bypasses all Row Level Security.
      It must NEVER appear in client-side code or be committed to git.

─── 1D. (Optional) Rotate Supabase JWT Secret ──────────────────────────────────
  This logs out ALL existing users. Only do this if sessions may be compromised.

  WHERE: Supabase Dashboard → Project Settings → API → JWT Settings
  Action: Click "Generate new JWT secret" → confirm.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
STEP 2 — FILL IN BOTH .env FILES COMPLETELY
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

─── File: praxis_webapp/.env (backend) ─────────────────────────────────────────

  STRIPE_SECRET_KEY=sk_test_...          ← updated in Step 1A
  STRIPE_WEBHOOK_SECRET=whsec_...        ← get from Stripe CLI in Step 6C
  STRIPE_PRICE_ID=price_...             ← get from Stripe Dashboard in Step 5B
  SUPABASE_URL=https://<id>.supabase.co  ← Supabase Dashboard → Settings → API
  SUPABASE_SERVICE_ROLE_KEY=eyJ...       ← updated in Step 1C
  GEMINI_API_KEY=...                     ← Google AI Studio (for AI coaching)
  CLIENT_URL=http://localhost:3000       ← change to prod URL when deploying
  PORT=3001

─── File: praxis_webapp/client/.env (frontend) ─────────────────────────────────

  REACT_APP_SUPABASE_URL=https://<id>.supabase.co   ← same project URL as above
  REACT_APP_SUPABASE_ANON_KEY=eyJ...                ← updated in Step 1B
  REACT_APP_STRIPE_PUBLISHABLE_KEY=pk_test_...      ← from Stripe Dashboard (safe to expose)
  REACT_APP_API_URL=http://localhost:3001            ← change to prod URL when deploying

  How to find REACT_APP_STRIPE_PUBLISHABLE_KEY:
    → https://dashboard.stripe.com/test/apikeys
    → Copy the "Publishable key" (starts with pk_test_...)

  After editing either .env file: restart your dev servers.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
STEP 3 — GOOGLE CLOUD CONSOLE (for Google OAuth login)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  WHERE: https://console.cloud.google.com

─── 3A. Create a project ───────────────────────────────────────────────────────

  1. Click the project dropdown (top-left) → "New Project".
  2. Name it "Praxis" → click "Create".
  3. Make sure the new project is selected in the dropdown.

─── 3B. Configure the OAuth Consent Screen ─────────────────────────────────────

  1. Left menu → "APIs & Services" → "OAuth consent screen".
  2. User Type: select "External" → click "Create".
  3. Fill in the required fields:
       App name:              Praxis
       User support email:    <your email>
       Developer contact:     <your email>
  4. Click "Save and Continue".
  5. Scopes screen: click "Add or Remove Scopes".
     Check all three of these:
       - .../auth/userinfo.email
       - .../auth/userinfo.profile
       - openid
     Click "Update" → "Save and Continue".
  6. Test users screen: add your own email address → "Save and Continue".
  7. Summary: click "Back to Dashboard".

─── 3C. Create OAuth 2.0 Credentials ───────────────────────────────────────────

  1. Left menu → "APIs & Services" → "Credentials".
  2. Click "+ Create Credentials" → "OAuth 2.0 Client ID".
  3. Application type: Web application.
  4. Name: "Praxis Web".
  5. Under "Authorized redirect URIs" → click "+ Add URI".
     Enter EXACTLY this (replace <your-project-id> with your Supabase project ID):

       https://<your-project-id>.supabase.co/auth/v1/callback

     Example: https://kuyzjjbeiawnnkkrjsda.supabase.co/auth/v1/callback

  6. Click "Create".
  7. A dialog shows your credentials. COPY BOTH NOW:
       Client ID:     ends in .apps.googleusercontent.com
       Client Secret: starts with GOCSPX-...
     You can retrieve these later from the Credentials list if needed.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
STEP 4 — SUPABASE DASHBOARD CONFIGURATION
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

─── 4A. Enable Google OAuth Provider ───────────────────────────────────────────
  WHERE: https://supabase.com/dashboard/project/<your-project-id>/auth/providers

  1. Scroll to "Google" in the provider list.
  2. Toggle it ON.
  3. Paste the values from Step 3C:
       Client ID (for OAuth):      <Google Client ID>
       Client Secret (for OAuth):  <Google Client Secret>
  4. Click "Save".

─── 4B. Set Site URL and Redirect URLs ─────────────────────────────────────────
  WHERE: https://supabase.com/dashboard/project/<your-project-id>/auth/url-configuration

  1. Site URL:
       Development: http://localhost:3000
       Production:  https://yourdomain.com  (update before deploying)

  2. Redirect URLs — click "Add URL" for EACH of the following:
       http://localhost:3000/**
       http://localhost:3000/dashboard
       http://localhost:3000/onboarding

     For production, also add:
       https://yourdomain.com/**

  3. Click "Save".

─── 4C. Email Confirmation Settings ────────────────────────────────────────────
  WHERE: Supabase Dashboard → Authentication → Settings

  Review the "Enable email confirmations" toggle.
  - ON  = users must verify email before logging in (more secure, standard for prod)
  - OFF = users can log in immediately after signup (easier for dev/testing)

  During development you may want this OFF to avoid having to check email
  every time you create a test account.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
STEP 5 — SUPABASE SQL EDITOR (run all four queries below)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  WHERE: https://supabase.com/dashboard/project/<your-project-id>/sql/new

  Open a "New Query" tab for each query. Paste it, then click "Run".

─── Query 1: handle_new_user trigger (email + Google OAuth) ────────────────────

  Purpose: When any new user signs up — whether via email/password or
  Google OAuth — automatically create their row in `public.profiles`.
  Google users send name/avatar_url differently from email users,
  so this handles both with COALESCE fallbacks.

  -- PASTE AND RUN:

  CREATE OR REPLACE FUNCTION public.handle_new_user()
  RETURNS trigger
  LANGUAGE plpgsql
  SECURITY DEFINER SET search_path = public
  AS $$
  BEGIN
    INSERT INTO public.profiles (id, name, email, avatar_url, is_premium, onboarding_completed)
    VALUES (
      NEW.id,
      COALESCE(
        NEW.raw_user_meta_data->>'name',
        NEW.raw_user_meta_data->>'full_name',
        SPLIT_PART(NEW.email, '@', 1)
      ),
      NEW.email,
      COALESCE(
        NEW.raw_user_meta_data->>'avatar_url',
        NEW.raw_user_meta_data->>'picture'
      ),
      false,
      false
    )
    ON CONFLICT (id) DO UPDATE SET
      avatar_url = COALESCE(profiles.avatar_url, EXCLUDED.avatar_url);
    RETURN NEW;
  END;
  $$;

  DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
  CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

─── Query 2: user_subscriptions table ──────────────────────────────────────────

  Purpose: Stores Stripe subscription records. The webhook handler in
  stripeController.ts writes here after each successful payment event.
  Skip this query if the table already exists (check Table Editor first).

  -- PASTE AND RUN:

  CREATE TABLE IF NOT EXISTS public.user_subscriptions (
    id                   TEXT PRIMARY KEY,
    user_id              UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    status               TEXT NOT NULL,
    customer_id          TEXT NOT NULL,
    price_id             TEXT,
    product_id           TEXT,
    current_period_start TIMESTAMPTZ,
    current_period_end   TIMESTAMPTZ,
    created_at           TIMESTAMPTZ DEFAULT NOW(),
    updated_at           TIMESTAMPTZ DEFAULT NOW()
  );

  ALTER TABLE public.user_subscriptions ENABLE ROW LEVEL SECURITY;

  DROP POLICY IF EXISTS "Users can view own subscription" ON public.user_subscriptions;
  CREATE POLICY "Users can view own subscription"
    ON public.user_subscriptions FOR SELECT
    USING (auth.uid() = user_id);

─── Query 3: update_profile_premium_status trigger ─────────────────────────────

  Purpose: Automatically sets profiles.is_premium = true when a subscription
  with status 'active' or 'trialing' exists for the user, and false when the
  subscription is cancelled or deleted. This is what makes the premium badge
  appear after a successful Stripe payment — no manual update needed.

  -- PASTE AND RUN:

  CREATE OR REPLACE FUNCTION public.update_profile_premium_status()
  RETURNS trigger
  LANGUAGE plpgsql
  SECURITY DEFINER SET search_path = public
  AS $$
  BEGIN
    IF (TG_OP = 'DELETE') THEN
      UPDATE public.profiles
        SET is_premium = false
        WHERE id = OLD.user_id;
      RETURN OLD;
    ELSE
      UPDATE public.profiles
        SET is_premium = (NEW.status IN ('active', 'trialing'))
        WHERE id = NEW.user_id;
      RETURN NEW;
    END IF;
  END;
  $$;

  DROP TRIGGER IF EXISTS on_subscription_change ON public.user_subscriptions;
  CREATE TRIGGER on_subscription_change
    AFTER INSERT OR UPDATE OR DELETE ON public.user_subscriptions
    FOR EACH ROW EXECUTE PROCEDURE public.update_profile_premium_status();

─── Query 4: messages table + RLS (required for chat) ──────────────────────────

  Purpose: Stores chat messages between users. The ChatRoom component reads
  and writes here via the Express backend (messageController.ts).
  Skip if the table already exists.

  -- PASTE AND RUN:

  CREATE TABLE IF NOT EXISTS public.messages (
    id          UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    sender_id   UUID REFERENCES auth.users(id),
    receiver_id UUID REFERENCES auth.users(id),
    content     TEXT NOT NULL,
    goal_node_id TEXT,
    timestamp   TIMESTAMPTZ DEFAULT NOW()
  );

  ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

  DROP POLICY IF EXISTS "Users can read their own messages" ON public.messages;
  CREATE POLICY "Users can read their own messages"
    ON public.messages FOR SELECT
    USING (auth.uid() = sender_id OR auth.uid() = receiver_id);

  DROP POLICY IF EXISTS "Users can send messages" ON public.messages;
  CREATE POLICY "Users can send messages"
    ON public.messages FOR INSERT
    WITH CHECK (auth.uid() = sender_id);

─── Query 5: Verify triggers are installed ─────────────────────────────────────

  Run this after the queries above to confirm everything is wired up.
  You should see at least: on_auth_user_created, on_subscription_change.

  -- PASTE AND RUN:

  SELECT trigger_name, event_object_schema, event_object_table, action_timing, event_manipulation
  FROM information_schema.triggers
  WHERE trigger_name IN ('on_auth_user_created', 'on_subscription_change')
  ORDER BY trigger_name;

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
STEP 6 — STRIPE DASHBOARD + CLI SETUP
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

─── 6A. Create a Product and Price ─────────────────────────────────────────────
  WHERE: https://dashboard.stripe.com/test/products/create

  1. Product name: "Praxis Premium"
  2. Pricing model: Standard pricing
  3. Price: 10.00 USD, Monthly (recurring)
  4. Click "Save product".
  5. On the product page, under "Pricing", find and copy the Price ID.
     It looks like: price_1AbCdEfGhIjKlMnO...
  6. Add to praxis_webapp/.env:
       STRIPE_PRICE_ID=price_1AbCdEfGhIjKlMnO...

─── 6B. Install the Stripe CLI ─────────────────────────────────────────────────

  On Debian/Ubuntu Linux:

    sudo apt install stripe

  Or download manually:
    https://github.com/stripe/stripe-cli/releases/latest
    → Download stripe_linux_x86_64.tar.gz
    → tar -xzf stripe_linux_x86_64.tar.gz
    → sudo mv stripe /usr/local/bin/stripe

  Verify:
    stripe --version

─── 6C. Login and forward webhooks locally ─────────────────────────────────────

  Step 1 — Login (opens a browser):
    stripe login

  Step 2 — With your backend running on port 3001, open a second terminal and run:
    stripe listen --forward-to localhost:3001/stripe/webhook

  Step 3 — The CLI prints something like:
    > Ready! Your webhook signing secret is whsec_abc123def456ghi789...

  Step 4 — Copy that whsec_... value.
  Step 5 — Add to praxis_webapp/.env:
       STRIPE_WEBHOOK_SECRET=whsec_abc123def456ghi789...

  Step 6 — Restart the backend server so it reads the new env var.

  IMPORTANT: Keep this `stripe listen` terminal open while testing locally.
             The whsec_ from the CLI is different from the Dashboard webhook
             secret — use the CLI one for local dev only.

─── 6D. Test a payment end-to-end ──────────────────────────────────────────────

  Run all three simultaneously:
    Terminal 1: npm run dev          (from praxis_webapp/ — backend on :3001)
    Terminal 2: stripe listen --forward-to localhost:3001/stripe/webhook
    Terminal 3: npm start            (from praxis_webapp/client/ — frontend on :3000)

  Test flow:
    1. Log in as any test user → go to /upgrade
    2. Click "Get Started Now"
    3. Stripe Checkout opens. Use this test card:
         Number:  4242 4242 4242 4242
         Expiry:  Any future date (e.g. 12/29)
         CVC:     Any 3 digits (e.g. 123)
         Name:    Anything
    4. Click "Subscribe" → redirected to /success
    5. Check Stripe CLI terminal → should show:
         checkout.session.completed
         customer.subscription.created
    6. Check Supabase Table Editor:
         → public.user_subscriptions: new row, status = 'active'
         → public.profiles: is_premium = true for that user ✓

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
STEP 7 — SUPABASE: ENABLE REALTIME ON messages TABLE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  WHERE: Supabase Dashboard → Database → Replication

  1. Find the "messages" table in the list.
  2. Toggle it ON under "Realtime".
  3. Save.

  This is required for live chat in ChatRoom.tsx to receive new messages
  without the user having to refresh the page.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
STEP 8 — BACKEND CODE CHANGES (manual edits required)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

─── 8A. Add completeOnboarding to userController.ts ────────────────────────────
  FILE: praxis_webapp/src/controllers/userController.ts

  Add this function. Make sure supabase, catchAsync, and BadRequestError are
  already imported at the top of that file (they should be):

    export const completeOnboarding = catchAsync(async (req, res, _next) => {
      const { userId } = req.body;
      if (!userId) throw new BadRequestError('userId is required.');

      const { error } = await supabase
        .from('profiles')
        .update({ onboarding_completed: true })
        .eq('id', userId);

      if (error) throw new Error(`Failed to update onboarding: ${error.message}`);

      res.status(200).json({ message: 'Onboarding complete.' });
    });

─── 8B. Register the route in userRoutes.ts ────────────────────────────────────
  FILE: praxis_webapp/src/routes/userRoutes.ts

  Add this import and route:

    import { completeOnboarding } from '../controllers/userController';
    router.post('/complete-onboarding', completeOnboarding);

─── 8C. Call it from the frontend onboarding flow ──────────────────────────────
  FILE: whichever component has your final onboarding "Finish" button
        (likely client/src/features/onboarding/components/InitialGoalSetup.tsx)

  After saving goals, before navigating away:

    import axios from 'axios';
    import { API_URL } from '../../../lib/api';  // adjust relative path

    // In the finish/submit handler:
    await axios.post(`${API_URL}/users/complete-onboarding`, { userId: user.id });
    navigate('/dashboard');

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
STEP 9 — INSTALL MISSING FRONTEND DEPENDENCIES
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  Run from praxis_webapp/client/:

    npm install recharts @mui/x-charts

  Verify framer-motion is already present (it should be):

    npm list framer-motion

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
STEP 10 — PRODUCTION WEBHOOK (when you deploy the backend)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  WHERE: https://dashboard.stripe.com/test/webhooks/create

  When the backend is deployed to a public URL, replace the Stripe CLI
  tunnel with a real registered webhook endpoint.

  1. Endpoint URL:    https://your-backend-domain.com/stripe/webhook
  2. Events to send: checkout.session.completed
                     customer.subscription.updated
                     customer.subscription.deleted
  3. Click "Add endpoint".
  4. On the endpoint detail page, reveal and copy the "Signing secret" (whsec_...).
  5. Set in your production environment (NOT in code):
       STRIPE_WEBHOOK_SECRET=whsec_...  ← Dashboard secret, different from CLI secret

  For production keys (not test), repeat Steps 6A and 10 on the live dashboard:
    https://dashboard.stripe.com/products/create
    https://dashboard.stripe.com/webhooks/create

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
CHECKLIST — TICK OFF AS YOU COMPLETE EACH ITEM
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  [ ] 1A  Stripe secret key rolled → updated in praxis_webapp/.env
  [ ] 1B  Supabase anon key rotated → updated in praxis_webapp/client/.env
  [ ] 1C  Supabase service role key rotated → updated in praxis_webapp/.env
  [ ] 2   All env vars present and filled in both .env files
  [ ] 3A  Google Cloud project created
  [ ] 3B  OAuth consent screen configured (External, email + profile + openid)
  [ ] 3C  OAuth 2.0 Client ID created, Supabase callback URI added
  [ ] 4A  Google provider enabled in Supabase with Client ID + Secret
  [ ] 4B  Supabase redirect URLs configured (localhost:3000/**)
  [ ] 4C  Email confirmation setting reviewed
  [ ] 5Q1 handle_new_user trigger updated in Supabase SQL Editor
  [ ] 5Q2 user_subscriptions table created in Supabase SQL Editor
  [ ] 5Q3 update_profile_premium_status trigger created in Supabase SQL Editor
  [ ] 5Q4 messages table created in Supabase SQL Editor
  [ ] 5Q5 Verification query run — both triggers confirmed present
  [ ] 6A  Stripe product "Praxis Premium" created, price_... added to .env
  [ ] 6B  Stripe CLI installed
  [ ] 6C  stripe listen running, whsec_... added to praxis_webapp/.env
  [ ] 6D  End-to-end payment test passing (subscription row + is_premium = true)
  [ ] 7   Realtime enabled for messages table in Supabase Dashboard
  [ ] 8A  completeOnboarding function added to userController.ts
  [ ] 8B  Route registered in userRoutes.ts
  [ ] 8C  Frontend calls complete-onboarding endpoint at end of onboarding flow
  [ ] 9   recharts and @mui/x-charts installed in client/
  [ ] 10  (Prod) Real webhook endpoint registered in Stripe Dashboard
  [ ] 11  Backend deployed to Railway (Procfile committed, env vars set)
  [ ] 12  Frontend deployed to Vercel (REACT_APP_API_URL set to Railway URL)
  [ ] 13  Demo users seeded via POST /admin/seed-demo-users (ADMIN_SECRET set)
  [ ] 14  SSH key authorized on GitHub and git push completed

================================================================================

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
STEP 11 — DEPLOY BACKEND TO RAILWAY
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  WHERE: https://railway.app

Railway detects Node.js apps automatically. The Procfile (already committed)
tells it to run `node dist/index.js`.

─── 11A. Push your code to GitHub first ────────────────────────────────────────

  1. Add your SSH key to GitHub:
       → https://github.com/settings/keys → "New SSH key"
       → Paste the contents of ~/.ssh/id_ed25519.pub
       → Save
  2. Push all commits:
       git push origin main

─── 11B. Create a Railway project ──────────────────────────────────────────────

  1. Go to https://railway.app → "New Project"
  2. Choose "Deploy from GitHub repo"
  3. Select your repo: ilPez00/praxis_webapp
  4. Railway will auto-detect Node.js and start a deployment (it will fail
     until you add env vars in the next step — that's expected)

─── 11C. Add backend environment variables ─────────────────────────────────────
  WHERE: Railway Dashboard → your project → "Variables" tab

  Add EACH of these exactly:

    SUPABASE_URL              = https://kuyzjjbeiawnnkkrjsda.supabase.co
    SUPABASE_SERVICE_ROLE_KEY = <your rotated service role key from Step 1C>
    GEMINI_API_KEY            = <your Google AI Studio key>
    STRIPE_SECRET_KEY         = <your rotated Stripe secret key from Step 1A>
    STRIPE_PRICE_ID           = price_...   ← from Stripe Dashboard
    STRIPE_WEBHOOK_SECRET     = whsec_...   ← from Step 10 (prod webhook)
    CLIENT_URL                = https://your-frontend.vercel.app  ← add after Step 12
    ADMIN_SECRET              = <choose a long random string — keep it secret>
    NODE_ENV                  = production

  ⚠️  Do NOT set PORT — Railway injects it automatically.

─── 11D. Set the build command ─────────────────────────────────────────────────
  WHERE: Railway → Settings → Build

  Build command:   npm install && npm run build
  Start command:   node dist/index.js

  Or Railway reads the Procfile automatically: `web: node dist/index.js`

─── 11E. Get your Railway URL ──────────────────────────────────────────────────

  After a successful deployment:
    → Railway Dashboard → Deployments → your live URL
    It will look like: https://praxis-webapp-production.up.railway.app

  Save this URL. You'll need it in Step 12.

─── 11F. Update Stripe webhook endpoint ────────────────────────────────────────
  WHERE: https://dashboard.stripe.com/test/webhooks

  1. Add a new webhook endpoint:
       URL: https://your-railway-url.up.railway.app/stripe/webhook
       Events: checkout.session.completed, customer.subscription.updated,
               customer.subscription.deleted
  2. Copy the new signing secret (whsec_...) → update STRIPE_WEBHOOK_SECRET
     in Railway Variables (this replaces the CLI secret from Step 6C)
  3. Redeploy (Railway → "Deploy" button, or push a commit)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
STEP 12 — DEPLOY FRONTEND TO VERCEL
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  WHERE: https://vercel.com

─── 12A. Install Vercel CLI (optional but handy) ───────────────────────────────

    npm install -g vercel

─── 12B. Create a Vercel project ───────────────────────────────────────────────

  Option A (recommended — Vercel dashboard):
    1. Go to https://vercel.com/new
    2. Import your GitHub repo (ilPez00/praxis_webapp)
    3. Set the Root Directory to: client
       (IMPORTANT — Vercel must build from the client/ folder, not root)
    4. Framework Preset: Create React App
    5. Do NOT deploy yet — set env vars first (Step 12C)

  Option B (CLI):
    cd /home/gio/Praxis/praxis_webapp/client
    vercel
    → Follow prompts, set root to client/

─── 12C. Set frontend environment variables ────────────────────────────────────
  WHERE: Vercel Dashboard → your project → Settings → Environment Variables

  Add EACH of these:

    REACT_APP_SUPABASE_URL          = https://kuyzjjbeiawnnkkrjsda.supabase.co
    REACT_APP_SUPABASE_ANON_KEY     = <your rotated anon key from Step 1B>
    REACT_APP_STRIPE_PUBLISHABLE_KEY = pk_test_...  ← from Stripe Dashboard
    REACT_APP_API_URL               = https://your-railway-url.up.railway.app
                                      ← replace with your actual Railway URL

  Click "Save" after adding all four.

─── 12D. Deploy ────────────────────────────────────────────────────────────────

  Click "Deploy" in the Vercel dashboard, or:
    cd /home/gio/Praxis/praxis_webapp/client && vercel --prod

  Your live URL will be: https://praxis-webapp.vercel.app (or similar)

─── 12E. Update Supabase redirect URLs ─────────────────────────────────────────
  WHERE: Supabase Dashboard → Authentication → URL Configuration

  Add your Vercel URL to Redirect URLs:
    https://your-app.vercel.app/**
    https://your-app.vercel.app/dashboard
    https://your-app.vercel.app/onboarding

─── 12F. Update Railway CLIENT_URL ─────────────────────────────────────────────
  WHERE: Railway → Variables

  Update:  CLIENT_URL = https://your-app.vercel.app

  This is used by the backend for CORS and Stripe success/cancel redirects.
  After updating, trigger a redeploy.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
STEP 13 — SEED DEMO USERS (run after deployment)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  This seeds 7 realistic demo profiles with goal trees so new users see
  meaningful matches on day one, not an empty list.

  Requires:
    - Backend deployed and running (Step 11)
    - ADMIN_SECRET set in Railway environment variables
    - Supabase goal_trees table exists (Step 5, Query 4)

─── 13A. Call the seed endpoint ────────────────────────────────────────────────

  Replace <YOUR_ADMIN_SECRET> with the value you set in Railway Variables.
  Replace <RAILWAY_URL> with your actual Railway backend URL.

  From your terminal:

    curl -X POST https://<RAILWAY_URL>/admin/seed-demo-users \
      -H "X-Admin-Secret: <YOUR_ADMIN_SECRET>" \
      -H "Content-Type: application/json"

  Expected response:
    { "message": "Demo seed complete. 7 created, 0 skipped.", "results": [...] }

  Running it again is safe — it skips users that already exist.

─── 13B. Verify in Supabase ────────────────────────────────────────────────────
  WHERE: Supabase Dashboard → Table Editor → profiles

  Filter by is_demo = true. You should see 7 rows:
    Sara Milano, Yuki Tanaka, Priya Sharma, Marco Chen, Lena Müller,
    Carlos Reyes, Tom Hansen

  Each should have:
    - name, bio, avatar_url filled in
    - onboarding_completed = true
    - is_demo = true

  Also check goal_trees → each demo user should have 3 goal nodes.

─── 13C. Test matching ─────────────────────────────────────────────────────────

  1. Log in as your own test account
  2. Make sure you have at least one goal set (any domain)
  3. Navigate to /matches
  4. You should see real matches (the demo users) with compatibility scores

  If scores are all 0: the domain names may not match exactly between your
  goal tree and the demo users' goal trees. Check the Domain enum values.

================================================================================

