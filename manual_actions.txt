================================================================================
  PRAXIS — MANUAL ACTIONS REQUIRED
  Read this file top to bottom. Each step has: WHERE to do it, WHAT to do,
  and WHAT SUCCESS LOOKS LIKE.
================================================================================

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
QUICK START — minimum steps to get the app running locally
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

If you just want to run the app locally NOW, do only these 4 things:

  Q1. Open: https://supabase.com/dashboard/project/_/settings/api
      Copy "Project URL" → paste as SUPABASE_URL in praxis_webapp/.env
      Copy "service_role" key → paste as SUPABASE_SERVICE_ROLE_KEY in praxis_webapp/.env

  Q2. Run the SQL in Step 5 of this file to create the profiles + messages tables.
      (Takes ~2 minutes.)

  Q3. Enable Realtime on the messages table (Step 7).

  Q4. Run:
        chmod +x run_praxis.sh
        ./run_praxis.sh

  That's it. Frontend will open at http://localhost:3000.
  Some features (Stripe, AI coaching) won't work without more setup — see below.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
FULL SETUP CHECKLIST  (tick each box as you complete it)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  [ ] 0   Push code to GitHub (authorize SSH key, git push)
  [ ] 1A  Stripe secret key rolled / set in .env
  [ ] 1B  Supabase anon key rotated / set in client/.env
  [ ] 1C  Supabase service role key rotated / set in .env
  [ ] 2   Both .env files fully filled in
  [ ] 3   (Optional) Google OAuth configured in Supabase
  [ ] 4   Supabase auth redirect URLs set to include localhost:3000/**
  [ ] 5Q1 profiles table created + handle_new_user trigger installed
  [ ] 5Q2 user_subscriptions table created
  [ ] 5Q3 update_profile_premium_status trigger installed
  [ ] 5Q4 messages table created
  [ ] 5Q5 goal_tree_edit_count column added to profiles (free re-edit gate)
  [ ] 6A  Stripe product "Praxis Premium" created, price_... set in .env
  [ ] 6B  Stripe CLI installed
  [ ] 6C  stripe listen running, whsec_... set in .env
  [ ] 6D  End-to-end payment test passing
  [ ] 7   Realtime enabled for messages table
  [ ] 8   completeOnboarding endpoint wired (see Step 8)
  [ ] 9   recharts + @mui/x-charts installed
  [ ] 10  (Prod) Stripe webhook registered at production URL
  [ ] 11  Backend deployed to Railway
  [ ] 12  Frontend deployed to Vercel
  [ ] 13  Demo users seeded via POST /admin/seed-demo-users
  [ ] 14  SSH key authorized at github.com/settings/keys

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
STEP 0 — PUSH CODE TO GITHUB
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

The repo is at https://github.com/ilPez00/praxis_webapp.
There are ~10 commits that haven't been pushed because the SSH key hasn't been
authorized on GitHub yet.

─── 0A. Authorize your SSH key on GitHub ────────────────────────────────────────

  1. Open a terminal on THIS machine and run:
       cat ~/.ssh/id_ed25519.pub
     Copy the entire output (starts with "ssh-ed25519 ...")

  2. Go to: https://github.com/settings/keys
  3. Click "New SSH key"
  4. Title: anything (e.g. "dev laptop")
  5. Key type: Authentication Key
  6. Paste the key text from step 1
  7. Click "Add SSH key"

─── 0B. Push all local commits ─────────────────────────────────────────────────

  Run from praxis_webapp/:
    git push origin main

  Expected output:
    Enumerating objects: ...
    To github.com:ilPez00/praxis_webapp.git
       <old-sha>..<new-sha>  main -> main

  ✓ Success: you'll see "main -> main" at the end with no errors.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
STEP 1 — ROTATE EXPOSED KEYS  ⚠️  DO THIS BEFORE DEPLOYING
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

The Supabase anon key and Stripe publishable key were in committed files.
Rotate them now so the old ones are invalidated.

─── 1A. Rotate Stripe Secret Key ────────────────────────────────────────────────
  WHERE: https://dashboard.stripe.com/test/apikeys

  1. Find "Secret key" row (starts with sk_test_...)
  2. Click the "..." menu → "Roll key" → confirm
  3. Copy the NEW secret key
  4. Open praxis_webapp/.env
     Update: STRIPE_SECRET_KEY=sk_test_<new_value>

─── 1B. Rotate Supabase Anon Key ────────────────────────────────────────────────
  WHERE: https://supabase.com/dashboard/project/kuyzjjbeiawnnkkrjsda/settings/api
  (replace "kuyzjjbeiawnnkkrjsda" with YOUR project ID if different)

  1. Under "Project API keys" → find "anon / public"
  2. Click "Generate new key" → confirm
  3. Copy the new anon key
  4. Open praxis_webapp/client/.env
     Update: REACT_APP_SUPABASE_ANON_KEY=<new_value>

─── 1C. Rotate Supabase Service Role Key ────────────────────────────────────────
  WHERE: Same page as 1B

  1. Find "service_role" row → "Generate new key" → confirm
  2. Copy the new service role key
  3. Open praxis_webapp/.env
     Update: SUPABASE_SERVICE_ROLE_KEY=<new_value>

  ⚠️  The service role key bypasses ALL Row Level Security.
      NEVER put it in client-side code or commit it to git.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
STEP 2 — FILL IN BOTH .env FILES
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

─── File: praxis_webapp/.env (backend) ─────────────────────────────────────────

  SUPABASE_URL=https://kuyzjjbeiawnnkkrjsda.supabase.co
    ← copy from Supabase Dashboard → Project Settings → API → Project URL

  SUPABASE_SERVICE_ROLE_KEY=eyJ...
    ← from Step 1C (or Supabase → Settings → API → service_role)

  STRIPE_SECRET_KEY=sk_test_...
    ← from Step 1A (or https://dashboard.stripe.com/test/apikeys)

  STRIPE_WEBHOOK_SECRET=whsec_...
    ← from Step 6C (Stripe CLI) or Step 10 (prod webhook)

  STRIPE_PRICE_ID=price_...
    ← from Step 6A (Stripe Dashboard → Products)

  GEMINI_API_KEY=...
    ← from https://aistudio.google.com/apikey
    (if blank, matching falls back to domain-overlap scoring — app still works)

  CLIENT_URL=http://localhost:3000
    ← change to your Vercel URL when deploying

  ADMIN_SECRET=choose_any_long_random_string_here
    ← used to protect POST /admin/seed-demo-users

  PORT=3001
    ← keep as is for local dev; Railway injects its own PORT at runtime

─── File: praxis_webapp/client/.env (frontend) ─────────────────────────────────

  REACT_APP_SUPABASE_URL=https://kuyzjjbeiawnnkkrjsda.supabase.co
    ← same as backend SUPABASE_URL

  REACT_APP_SUPABASE_ANON_KEY=eyJ...
    ← from Step 1B (anon/public key — this one IS safe to be public)

  REACT_APP_STRIPE_PUBLISHABLE_KEY=pk_test_...
    ← from https://dashboard.stripe.com/test/apikeys → "Publishable key"

  REACT_APP_API_URL=http://localhost:3001
    ← change to your Railway URL when deploying

  GENERATE_SOURCEMAP=false
    ← leave as is (suppresses harmless face-api.js build warnings)

  After editing either .env: restart both dev servers.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
STEP 3 — GOOGLE OAUTH (optional — skip if using email/password only)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

─── 3A. Google Cloud Console ───────────────────────────────────────────────────
  WHERE: https://console.cloud.google.com

  1. Create a project named "Praxis"
  2. Left menu → APIs & Services → OAuth consent screen
     - User Type: External → Create
     - Fill: App name = Praxis, your email, developer contact
     - Scopes: add userinfo.email + userinfo.profile + openid
     - Test users: add your email
  3. Left menu → APIs & Services → Credentials
     → Create Credentials → OAuth 2.0 Client ID
     - Application type: Web application
     - Authorized redirect URIs → Add:
         https://kuyzjjbeiawnnkkrjsda.supabase.co/auth/v1/callback
     - Click Create → copy Client ID + Client Secret

─── 3B. Enable in Supabase ─────────────────────────────────────────────────────
  WHERE: https://supabase.com/dashboard/project/kuyzjjbeiawnnkkrjsda/auth/providers

  1. Scroll to Google → toggle ON
  2. Paste Client ID and Client Secret from 3A
  3. Click Save

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
STEP 4 — SUPABASE AUTH REDIRECT URLS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  WHERE: https://supabase.com/dashboard/project/kuyzjjbeiawnnkkrjsda/auth/url-configuration

  1. Site URL:          http://localhost:3000
  2. Redirect URLs — click "Add URL" for EACH:
       http://localhost:3000/**
       http://localhost:3000/dashboard
       http://localhost:3000/onboarding
     For production, also add:
       https://your-vercel-app.vercel.app/**
  3. Save

  Also check: Authentication → Settings → "Enable email confirmations"
  - For dev/testing: set to OFF so you can sign up without email verification
  - For production: set to ON

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
STEP 5 — SUPABASE SQL (run each query in SQL Editor)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  WHERE: https://supabase.com/dashboard/project/kuyzjjbeiawnnkkrjsda/sql/new

  Open a NEW QUERY tab for each block below. Paste → click RUN.
  ✓ Success: "Success. No rows returned" (for DDL statements)

─── Query 1: profiles table + handle_new_user trigger ─────────────────────────

  -- Create profiles table (stores name, bio, avatar, premium status, etc.)
  CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT,
    age INT,
    bio TEXT,
    avatar_url TEXT,
    email TEXT,
    is_premium BOOLEAN DEFAULT false,
    onboarding_completed BOOLEAN DEFAULT false,
    is_demo BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ DEFAULT now()
  );

  -- Row Level Security
  ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
  DROP POLICY IF EXISTS "Users can read own profile" ON profiles;
  DROP POLICY IF EXISTS "Users can update own profile" ON profiles;
  CREATE POLICY "Users can read own profile" ON profiles
    FOR SELECT USING (auth.uid() = id);
  CREATE POLICY "Users can update own profile" ON profiles
    FOR UPDATE USING (auth.uid() = id);

  -- Allow admin (service role) to read all profiles (for matching engine)
  DROP POLICY IF EXISTS "Service role can read all profiles" ON profiles;
  CREATE POLICY "Service role can read all profiles" ON profiles
    FOR SELECT USING (true);

  -- Auto-create profile row when user signs up (email or Google OAuth)
  CREATE OR REPLACE FUNCTION public.handle_new_user()
  RETURNS TRIGGER AS $$
  BEGIN
    INSERT INTO public.profiles (id, name, email, avatar_url, onboarding_completed)
    VALUES (
      NEW.id,
      COALESCE(
        NEW.raw_user_meta_data->>'name',
        NEW.raw_user_meta_data->>'full_name',
        split_part(NEW.email, '@', 1)
      ),
      NEW.email,
      COALESCE(
        NEW.raw_user_meta_data->>'avatar_url',
        NEW.raw_user_meta_data->>'picture'
      ),
      false
    )
    ON CONFLICT (id) DO UPDATE SET
      avatar_url = COALESCE(profiles.avatar_url, EXCLUDED.avatar_url);
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql SECURITY DEFINER;

  DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
  CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

  -- Verify it worked:
  SELECT routine_name FROM information_schema.routines
    WHERE routine_name = 'handle_new_user';
  -- ✓ Expected: 1 row returned

─── Query 2: user_subscriptions table (Stripe integration) ────────────────────

  CREATE TABLE IF NOT EXISTS public.user_subscriptions (
    id                   TEXT PRIMARY KEY,
    user_id              UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    status               TEXT NOT NULL,
    customer_id          TEXT NOT NULL,
    price_id             TEXT,
    product_id           TEXT,
    current_period_start TIMESTAMPTZ,
    current_period_end   TIMESTAMPTZ,
    created_at           TIMESTAMPTZ DEFAULT NOW(),
    updated_at           TIMESTAMPTZ DEFAULT NOW()
  );

  ALTER TABLE public.user_subscriptions ENABLE ROW LEVEL SECURITY;
  DROP POLICY IF EXISTS "Users can view own subscription" ON public.user_subscriptions;
  CREATE POLICY "Users can view own subscription"
    ON public.user_subscriptions FOR SELECT USING (auth.uid() = user_id);

─── Query 3: update_profile_premium_status trigger ────────────────────────────

  -- Automatically sets is_premium on profile when subscription status changes.
  CREATE OR REPLACE FUNCTION public.update_profile_premium_status()
  RETURNS TRIGGER AS $$
  BEGIN
    IF (TG_OP = 'DELETE') THEN
      UPDATE public.profiles SET is_premium = false WHERE id = OLD.user_id;
      RETURN OLD;
    ELSIF (NEW.status IN ('active', 'trialing')) THEN
      UPDATE public.profiles SET is_premium = true WHERE id = NEW.user_id;
    ELSE
      UPDATE public.profiles SET is_premium = false WHERE id = NEW.user_id;
    END IF;
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql SECURITY DEFINER;

  DROP TRIGGER IF EXISTS on_subscription_change ON public.user_subscriptions;
  CREATE TRIGGER on_subscription_change
    AFTER INSERT OR UPDATE OR DELETE ON public.user_subscriptions
    FOR EACH ROW EXECUTE FUNCTION public.update_profile_premium_status();

─── Query 4: messages table (real-time chat) ──────────────────────────────────

  CREATE TABLE IF NOT EXISTS messages (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    sender_id UUID REFERENCES auth.users(id),
    receiver_id UUID REFERENCES auth.users(id),
    content TEXT NOT NULL,
    goal_node_id TEXT,
    timestamp TIMESTAMPTZ DEFAULT now()
  );

  ALTER TABLE messages ENABLE ROW LEVEL SECURITY;
  DROP POLICY IF EXISTS "Users can read own messages" ON messages;
  DROP POLICY IF EXISTS "Users can send messages" ON messages;
  CREATE POLICY "Users can read own messages"
    ON messages FOR SELECT USING (auth.uid() = sender_id OR auth.uid() = receiver_id);
  CREATE POLICY "Users can send messages"
    ON messages FOR INSERT WITH CHECK (auth.uid() = sender_id);

─── Query 5: goal_tree_edit_count column (free re-edit gate) ─────────────────

  -- Tracks how many times a user has re-edited their goal tree after initial setup.
  -- 0 = free re-edit still available; 1+ = Premium required.
  ALTER TABLE profiles
    ADD COLUMN IF NOT EXISTS goal_tree_edit_count INT DEFAULT 0;

  -- ✓ Expected: "Success. No rows returned"

─── Query 6: verify all tables exist ──────────────────────────────────────────

  SELECT table_name FROM information_schema.tables
    WHERE table_schema = 'public'
    ORDER BY table_name;
  -- ✓ Expected: profiles, user_subscriptions, messages (+ any others)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
STEP 6 — STRIPE SETUP
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

─── 6A. Create "Praxis Premium" product ────────────────────────────────────────
  WHERE: https://dashboard.stripe.com/test/products/create

  1. Name: Praxis Premium
  2. Pricing model: Recurring
  3. Price: €9.99/month  (or whatever you decide)
  4. Click "Save product"
  5. On the product page, find the "API ID" for the price — looks like:
       price_1T1s7gI...
  6. Add to praxis_webapp/.env:
       STRIPE_PRICE_ID=price_<that_value>

─── 6B. Install Stripe CLI ─────────────────────────────────────────────────────
  WHERE: Your terminal

  On Linux (Debian/Ubuntu):
    curl -s https://packages.stripe.dev/api/security/keypair/stripe-cli-gpg/public \
      | gpg --dearmor | sudo tee /usr/share/keyrings/stripe.gpg > /dev/null
    echo "deb [signed-by=/usr/share/keyrings/stripe.gpg] \
      https://packages.stripe.dev/stripe-cli-debian-local stable main" \
      | sudo tee /etc/apt/sources.list.d/stripe.list
    sudo apt update && sudo apt install stripe

  Verify: stripe --version
  ✓ Expected: stripe version X.Y.Z

─── 6C. Forward webhooks for local development ─────────────────────────────────
  WHERE: Your terminal (run with backend already running)

  1. Login: stripe login   (opens browser — authorize it)
  2. Start listener:
       stripe listen --forward-to localhost:3001/stripe/webhook
  3. The CLI prints:
       > Ready! Your webhook signing secret is whsec_abc123...
  4. Copy that whsec_... value
  5. Add to praxis_webapp/.env:
       STRIPE_WEBHOOK_SECRET=whsec_<that_value>
  6. Restart the backend server

  ⚠️  Keep this terminal open while testing payments.
      The whsec_ here is different from the production webhook secret.

─── 6D. Test a payment ─────────────────────────────────────────────────────────

  Run all three simultaneously:
    Terminal 1: npm run dev              (backend, from praxis_webapp/)
    Terminal 2: stripe listen --forward-to localhost:3001/stripe/webhook
    Terminal 3: npm start                (frontend, from praxis_webapp/client/)

  In the browser:
    1. Log in → go to /upgrade
    2. Click "Get Started Now" → Stripe Checkout opens
    3. Use test card:
         Number:  4242 4242 4242 4242
         Expiry:  12/29  (any future date)
         CVC:     123    (any 3 digits)
    4. Click Pay → redirected to /success

  ✓ Success:
    - Stripe CLI terminal shows: checkout.session.completed
    - Supabase Table Editor → user_subscriptions: 1 new row, status = 'active'
    - Supabase Table Editor → profiles: is_premium = true for your user

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
STEP 7 — ENABLE REALTIME ON messages TABLE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  WHERE: https://supabase.com/dashboard/project/kuyzjjbeiawnnkkrjsda/database/replication

  1. Click "0 tables" under "supabase_realtime" publication
  2. Find the "messages" table in the list
  3. Toggle it ON
  4. Click "Save"

  ✓ Success: Live chat messages now appear without page refresh.

  Alternative location if the above is different:
    Dashboard → Database → Replication → enable "messages"

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
STEP 8 — CREATE avatars STORAGE BUCKET
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  WHERE: https://supabase.com/dashboard/project/kuyzjjbeiawnnkkrjsda/storage/buckets

  1. Click "New bucket"
  2. Name: avatars
  3. Public: ON  (toggle to the right)
  4. Click "Save"

  ✓ Success: Profile photo uploads on /profile will work.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
STEP 9 — WIRE THE completeOnboarding ENDPOINT
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  The onboarding guard redirects new users to /onboarding until
  onboarding_completed = true in their profile. This endpoint sets it to true.

─── 9A. Add to userController.ts ───────────────────────────────────────────────
  FILE: praxis_webapp/src/controllers/userController.ts

  Add at the bottom (before the closing brace, after other exports):

    export const completeOnboarding = catchAsync(async (req, res, _next) => {
      const { userId } = req.body;
      if (!userId) throw new BadRequestError('userId is required.');
      const { error } = await supabase
        .from('profiles')
        .update({ onboarding_completed: true })
        .eq('id', userId);
      if (error) throw new Error(`Failed: ${error.message}`);
      res.status(200).json({ message: 'Onboarding complete.' });
    });

─── 9B. Register in userRoutes.ts ──────────────────────────────────────────────
  FILE: praxis_webapp/src/routes/userRoutes.ts

  Add import and route:
    import { completeOnboarding } from '../controllers/userController';
    router.post('/complete-onboarding', completeOnboarding);

─── 9C. Call it from the frontend ──────────────────────────────────────────────
  FILE: wherever your onboarding "Finish" button is
        (likely client/src/features/onboarding/OnboardingPage.tsx or InitialGoalSetup.tsx)

  In the finish handler, after saving goals:
    await axios.post(`${API_URL}/users/complete-onboarding`, { userId: user.id });
    navigate('/dashboard');

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
STEP 10 — INSTALL OPTIONAL FRONTEND PACKAGES
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  Run from praxis_webapp/client/:
    npm install recharts @mui/x-charts

  These are used by AnalyticsPage for charts. The page will show an error
  without them. Everything else works without this step.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
STEP 11 — DEPLOY BACKEND TO RAILWAY
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  WHERE: https://railway.app
  REQUIRES: Step 0 complete (code pushed to GitHub)

─── 11A. Create Railway project ─────────────────────────────────────────────────

  1. Sign in to Railway → "New Project"
  2. "Deploy from GitHub repo"
  3. Select: ilPez00/praxis_webapp
  4. Railway will detect Node.js automatically

─── 11B. Set environment variables ─────────────────────────────────────────────
  WHERE: Railway → your project → Variables tab

  Add EACH of these (copy from your local .env):

    SUPABASE_URL              = https://kuyzjjbeiawnnkkrjsda.supabase.co
    SUPABASE_SERVICE_ROLE_KEY = <your service role key>
    GEMINI_API_KEY            = <your Gemini key>
    STRIPE_SECRET_KEY         = <your Stripe secret key>
    STRIPE_PRICE_ID           = price_...
    STRIPE_WEBHOOK_SECRET     = whsec_... (from Step 11D, not the CLI one)
    CLIENT_URL                = https://your-app.vercel.app  (fill in after Step 12)
    ADMIN_SECRET              = <same value as local .env>
    NODE_ENV                  = production

  ⚠️  Do NOT set PORT — Railway sets it automatically.

─── 11C. Configure build settings ──────────────────────────────────────────────
  WHERE: Railway → Settings → Build

  Build command:  npm install && npm run build
  Start command:  node dist/index.js

  (The Procfile already says "web: node dist/index.js" — Railway reads this.)

─── 11D. Get your Railway URL + register Stripe webhook ─────────────────────────

  1. After successful deploy: Railway → Deployments → copy the URL
     Looks like: https://praxis-webapp-production.up.railway.app

  2. Register a production webhook at:
     https://dashboard.stripe.com/test/webhooks/create
     - Endpoint URL: https://<your-railway-url>/stripe/webhook
     - Events: checkout.session.completed, customer.subscription.updated,
               customer.subscription.deleted
     - Click "Add endpoint"
     - Reveal and copy the "Signing secret" (whsec_...)

  3. Update STRIPE_WEBHOOK_SECRET in Railway Variables with the new whsec_
  4. Click "Redeploy" in Railway

  ✓ Success: Railway dashboard shows "Active" deployment, no errors in logs.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
STEP 12 — DEPLOY FRONTEND TO VERCEL
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  WHERE: https://vercel.com/new
  REQUIRES: Step 0 (code on GitHub), Step 11 (Railway URL available)

─── 12A. Create project ─────────────────────────────────────────────────────────

  1. "Import Git Repository" → select ilPez00/praxis_webapp
  2. IMPORTANT: Set "Root Directory" to: client
     (Vercel must build from the client/ folder, not the root)
  3. Framework Preset: Create React App (Vercel should detect this)
  4. Don't deploy yet — set env vars first

─── 12B. Set environment variables ─────────────────────────────────────────────
  WHERE: Vercel → your project → Settings → Environment Variables

  Add these 5 variables:
    REACT_APP_SUPABASE_URL          = https://kuyzjjbeiawnnkkrjsda.supabase.co
    REACT_APP_SUPABASE_ANON_KEY     = <your rotated anon key>
    REACT_APP_STRIPE_PUBLISHABLE_KEY = pk_test_...
    REACT_APP_API_URL               = https://<your-railway-url>.up.railway.app
    GENERATE_SOURCEMAP              = false

  Click "Save" after each, or "Add All" if there's a bulk option.

─── 12C. Deploy ─────────────────────────────────────────────────────────────────

  Click "Deploy". Takes ~2 minutes.
  Your URL will be: https://praxis-webapp-xxx.vercel.app

─── 12D. Post-deploy updates ────────────────────────────────────────────────────

  1. Update Supabase redirect URLs (Step 4) to include your Vercel URL:
       https://your-app.vercel.app/**

  2. Update Railway → Variables → CLIENT_URL = https://your-app.vercel.app
     Then redeploy Railway.

  ✓ Success: Visiting your Vercel URL shows the Praxis login page.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
STEP 13 — SEED DEMO USERS (run after Railway is deployed)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  Seeds 7 realistic demo profiles with goal trees so new real users see
  meaningful matches from day one.

─── 13A. Run the seed command ───────────────────────────────────────────────────

  Replace <RAILWAY_URL> and <ADMIN_SECRET> with your actual values:

    curl -X POST https://<RAILWAY_URL>/admin/seed-demo-users \
      -H "X-Admin-Secret: <ADMIN_SECRET>" \
      -H "Content-Type: application/json"

  Example:
    curl -X POST https://praxis-production.up.railway.app/admin/seed-demo-users \
      -H "X-Admin-Secret: my-super-secret-admin-key" \
      -H "Content-Type: application/json"

  ✓ Expected response:
    {"message":"Demo seed complete. 7 created, 0 skipped.","results":[...]}

  Running again is safe — it skips existing users.

─── 13B. Verify in Supabase ────────────────────────────────────────────────────
  WHERE: Supabase → Table Editor → profiles

  Filter: is_demo = true
  ✓ Expected: 7 rows (Sara Milano, Yuki Tanaka, Priya Sharma, Marco Chen,
               Lena Müller, Carlos Reyes, Tom Hansen)

  Each should have:
    - name, bio, avatar_url filled in
    - onboarding_completed = true
    - is_demo = true

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
TROUBLESHOOTING
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  PROBLEM: Backend crashes with "Supabase URL and Service Role Key are required"
  FIX:     Add SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY to praxis_webapp/.env
           (see Step 2 for where to find these values)

  PROBLEM: Frontend shows "NetworkError" or "Failed to fetch" on API calls
  FIX:     Backend isn't running. Start it: cd praxis_webapp && npm run dev

  PROBLEM: Chat messages don't appear in real-time
  FIX:     Enable Realtime on messages table (Step 7)

  PROBLEM: Profile photo upload fails
  FIX:     Create the 'avatars' storage bucket in Supabase (Step 8)

  PROBLEM: Stripe Checkout doesn't redirect back correctly
  FIX:     Check that CLIENT_URL in .env matches where your frontend is running

  PROBLEM: Matches page always shows "0 matches"
  FIX 1:   Backend GEMINI_API_KEY is missing → matching still works with fallback,
            but both users need goal trees with at least one overlapping domain
  FIX 2:   Seed demo users (Step 13) so there's someone to match with

  PROBLEM: "Invalid or missing admin secret" from seed endpoint
  FIX:     Set ADMIN_SECRET in .env / Railway Variables and restart server

  PROBLEM: New user gets stuck at /onboarding with no way to complete it
  FIX:     Wire the complete-onboarding endpoint (Step 9)

  PROBLEM: face-api.js source map warnings in frontend console
  FIX:     Already fixed — GENERATE_SOURCEMAP=false in client/.env suppresses them

================================================================================
